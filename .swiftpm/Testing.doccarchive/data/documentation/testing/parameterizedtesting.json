{"primaryContentSections":[{"kind":"content","content":[{"text":"Overview","type":"heading","anchor":"Overview","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Some tests need to be run over many different inputs. For instance, a test might"},{"type":"text","text":" "},{"type":"text","text":"need to validate all cases of an enumeration. The testing library lets"},{"type":"text","text":" "},{"text":"developers specify one or more collections to iterate over during testing, with","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the elements of those collections being forwarded to a test function. An"},{"type":"text","text":" "},{"type":"text","text":"invocation of a test function with a particular set of argument values is called"},{"type":"text","text":" "},{"type":"text","text":"a test "},{"type":"emphasis","inlineContent":[{"type":"text","text":"case"}]},{"type":"text","text":"."}]},{"inlineContent":[{"type":"text","text":"By default, the test cases of a test function will run in parallel with each"},{"type":"text","text":" "},{"text":"other. For more information about test parallelization, see","type":"text"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.testing\/documentation\/Testing\/Parallelization"},{"text":".","type":"text"}],"type":"paragraph"},{"text":"Parameterizing over an array of values","type":"heading","anchor":"Parameterizing-over-an-array-of-values","level":2},{"inlineContent":[{"type":"text","text":"It is very common to want to run a test "},{"type":"emphasis","inlineContent":[{"type":"text","text":"n"}]},{"type":"text","text":" times over an array containing the"},{"text":" ","type":"text"},{"type":"text","text":"values that should be tested. Consider the following test function:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["enum Food {","  case burger, iceCream, burrito, noodleBowl, kebab","}","","@Test(\"All foods available\")","func foodsAvailable() async throws {","  for food: Food in [.burger, .iceCream, .burrito, .noodleBowl, .kebab] {","    let foodTruck = FoodTruck(selling: food)","    #expect(await foodTruck.cook(food))","  }","}"]},{"inlineContent":[{"text":"If this test function fails for one of the values in the array, it may be","type":"text"},{"type":"text","text":" "},{"text":"unclear which value failed. Instead, the test function can be ","type":"text"},{"inlineContent":[{"type":"text","text":"parameterized"},{"text":" ","type":"text"},{"type":"text","text":"over"}],"type":"emphasis"},{"text":" the various inputs:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["enum Food {","  case burger, iceCream, burrito, noodleBowl, kebab","}","","@Test(\"All foods available\", arguments: [Food.burger, .iceCream, .burrito, .noodleBowl, .kebab])","func foodAvailable(_ food: Food) async throws {","  let foodTruck = FoodTruck(selling: food)","  #expect(await foodTruck.cook(food))","}"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"When a collection is passed to the "},{"type":"codeVoice","code":"@Test"},{"type":"text","text":" attribute for parameterization, the"},{"text":" ","type":"text"},{"text":"testing library passes each element in the collection, one at a time, to the","type":"text"},{"type":"text","text":" "},{"type":"text","text":"test function as its first (and only) argument. Then, if the test fails for one"},{"type":"text","text":" "},{"type":"text","text":"or more inputs, the corresponding diagnostics can clearly indicate which inputs"},{"text":" ","type":"text"},{"type":"text","text":"need to be examined."}],"type":"paragraph"},{"type":"heading","level":2,"anchor":"Parameterizing-over-the-cases-of-an-enumeration","text":"Parameterizing over the cases of an enumeration"},{"type":"paragraph","inlineContent":[{"text":"In the example above, we hard-coded the list of ","type":"text"},{"type":"codeVoice","code":"Food"},{"type":"text","text":" cases to test. If "},{"type":"codeVoice","code":"Food"},{"type":"text","text":" "},{"type":"text","text":"is an enumeration conforming to "},{"type":"codeVoice","code":"CaseIterable"},{"text":", we can instead write:","type":"text"}]},{"syntax":"swift","code":["enum Food: CaseIterable {","  case burger, iceCream, burrito, noodleBowl, kebab","}","","@Test(\"All foods available\", arguments: Food.allCases)","func foodAvailable(_ food: Food) async throws {","  let foodTruck = FoodTruck(selling: food)","  #expect(await foodTruck.cook(food))","}"],"type":"codeListing"},{"inlineContent":[{"text":"This way, if a new case is added to the ","type":"text"},{"code":"Food","type":"codeVoice"},{"text":" enumeration, it will","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"automatically be tested by this test function."}],"type":"paragraph"},{"text":"Parameterizing over a range of integers","type":"heading","anchor":"Parameterizing-over-a-range-of-integers","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"It is possible to parameterize a test function over a closed range of integers:"}]},{"syntax":"swift","code":["@Test(\"Can make large orders\", arguments: 1 ... 100)","func makeLargeOrder(count: Int) async throws {","  let foodTruck = FoodTruck(selling: .burger)","  #expect(await foodTruck.cook(.burger, quantity: count))","}"],"type":"codeListing"},{"name":"Note","content":[{"type":"paragraph","inlineContent":[{"text":"Very large ranges such as ","type":"text"},{"type":"codeVoice","code":"0 ..< .max"},{"text":" may take an excessive amount of","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"time to test, or may never complete due to resource constraints."}]}],"type":"aside","style":"note"},{"anchor":"Testing-more-than-one-collection","text":"Testing more than one collection","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"It is possible to test more than one collection. Consider the following test"},{"type":"text","text":" "},{"type":"text","text":"function:"}],"type":"paragraph"},{"code":["@Test(\"Can make large orders\", arguments: Food.allCases, 1 ... 100)","func makeLargeOrder(of food: Food, count: Int) async throws {","  let foodTruck = FoodTruck(selling: food)","  #expect(await foodTruck.cook(food, quantity: count))","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Elements from the first collection are passed as the first argument to the test"},{"type":"text","text":" "},{"type":"text","text":"function, elements from the second collection are passed as the second argument,"},{"text":" ","type":"text"},{"text":"and so forth.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Assuming there are five cases in the ","type":"text"},{"type":"codeVoice","code":"Food"},{"type":"text","text":" enumeration, this test function"},{"text":" ","type":"text"},{"type":"text","text":"will, when run, be invoked 5 × 100 = 500 times with every possible combination"},{"text":" ","type":"text"},{"type":"text","text":"of food and order size. These combinations are referred to as the collections’"},{"text":" ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/en.wikipedia.org\/wiki\/Cartesian_product"},{"type":"text","text":"."}]},{"inlineContent":[{"text":"To avoid the combinatoric semantics shown above, use","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/zip(_:_:)","type":"reference","isActive":true},{"type":"text","text":":"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["@Test(\"Can make large orders\", arguments: zip(Food.allCases, 1 ... 100))","func makeLargeOrder(of food: Food, count: Int) async throws {","  let foodTruck = FoodTruck(selling: food)","  #expect(await foodTruck.cook(food, quantity: count))","}"]},{"type":"paragraph","inlineContent":[{"text":"The zipped sequence will be “destructured” into two arguments automatically,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"then passed to the test function for evaluation."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This revised test function will be invoked once for each tuple in the zipped"},{"type":"text","text":" "},{"text":"sequence, for a total of five invocations instead of 500 invocations. In other","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"words, this test function will be passed the inputs "},{"type":"codeVoice","code":"(.burger, 1)"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"(.iceCream, 2)"},{"type":"text","text":", …, "},{"code":"(.kebab, 5)","type":"codeVoice"},{"text":" instead of ","type":"text"},{"type":"codeVoice","code":"(.burger, 1)"},{"text":", ","type":"text"},{"type":"codeVoice","code":"(.burger, 2)"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"(.burger, 3)"},{"type":"text","text":", … "},{"type":"codeVoice","code":"(.kebab, 99)"},{"type":"text","text":", "},{"code":"(.kebab, 100)","type":"codeVoice"},{"text":".","type":"text"}]},{"anchor":"Running-selected-test-cases","text":"Running selected test cases","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"If a parameterized test meets certain requirements, the testing library allows","type":"text"},{"type":"text","text":" "},{"text":"users to run specific test cases it contains. This can be useful when a test","type":"text"},{"type":"text","text":" "},{"text":"has many cases but only some are failing since it enables re-running and","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"debugging the failing cases in isolation."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To support running selected test cases, it must be possible to deterministically"},{"type":"text","text":" "},{"type":"text","text":"match the test case’s arguments. When a user attempts to run selected test cases"},{"type":"text","text":" "},{"type":"text","text":"of a parameterized test function, the testing library evaluates each argument of"},{"type":"text","text":" "},{"text":"the tests’ cases for conformance to one of several known protocols, and if all","type":"text"},{"type":"text","text":" "},{"text":"arguments of a test case conform to one of those protocols, that test case can","type":"text"},{"type":"text","text":" "},{"type":"text","text":"be run selectively. The following lists the known protocols, in precedence order"},{"text":" ","type":"text"},{"type":"text","text":"(highest to lowest):"}]},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"type":"reference","identifier":"doc:\/\/org.swift.testing\/documentation\/Testing\/CustomTestArgumentEncodable","isActive":true},{"text":".","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"RawRepresentable"},{"type":"text","text":", where "},{"type":"codeVoice","code":"RawValue"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Encodable"},{"text":".","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Encodable"},{"type":"text","text":"."}]}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"Identifiable"},{"type":"text","text":", where "},{"code":"ID","type":"codeVoice"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Encodable"},{"text":".","type":"text"}],"type":"paragraph"}]}]},{"inlineContent":[{"text":"If any argument of a test case does not meet one of the above requirements, then","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the overall test case cannot be run selectively."}],"type":"paragraph"}]}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/org.swift.testing\/documentation\/Testing\/ParameterizedTesting"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/testing\/parameterizedtesting"]}],"schemaVersion":{"minor":3,"patch":0,"major":0},"topicSections":[{"identifiers":["doc:\/\/org.swift.testing\/documentation\/Testing\/Test(_:_:arguments:)-8kn7a","doc:\/\/org.swift.testing\/documentation\/Testing\/Test(_:_:arguments:_:)","doc:\/\/org.swift.testing\/documentation\/Testing\/Test(_:_:arguments:)-3rzok","doc:\/\/org.swift.testing\/documentation\/Testing\/CustomTestArgumentEncodable"]}],"hierarchy":{"paths":[["doc:\/\/org.swift.testing\/documentation\/Testing"]]},"kind":"article","sections":[],"metadata":{"modules":[{"name":"Testing"}],"title":"Parameterized testing","roleHeading":"API Collection","role":"collectionGroup"},"seeAlsoSections":[{"identifiers":["doc:\/\/org.swift.testing\/documentation\/Testing\/Test\/Parameter","doc:\/\/org.swift.testing\/documentation\/Testing\/Test\/Case"],"title":"Related Documentation"},{"identifiers":["doc:\/\/org.swift.testing\/documentation\/Testing\/DefiningTests","doc:\/\/org.swift.testing\/documentation\/Testing\/OrganizingTests"],"title":"Defining tests","generated":true}],"abstract":[{"text":"Run the same test multiple times with different inputs.","type":"text"}],"references":{"https://developer.apple.com/documentation/swift/zip(_:_:)":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/zip(_:_:)","type":"link","title":"zip()","titleInlineContent":[{"code":"zip()","type":"codeVoice"}],"url":"https:\/\/developer.apple.com\/documentation\/swift\/zip(_:_:)"},"doc://org.swift.testing/documentation/Testing/Test/Parameter":{"title":"Test.Parameter","abstract":[{"text":"A type representing a single parameter to a parameterized test function.","type":"text"}],"identifier":"doc:\/\/org.swift.testing\/documentation\/Testing\/Test\/Parameter","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Parameter"}],"kind":"symbol","role":"symbol","type":"topic","url":"\/documentation\/testing\/test\/parameter","navigatorTitle":[{"text":"Parameter","kind":"identifier"}]},"doc://org.swift.testing/documentation/Testing/Test(_:_:arguments:_:)":{"role":"symbol","title":"Test(_:_:arguments:_:)","url":"\/documentation\/testing\/test(_:_:arguments:_:)","kind":"symbol","identifier":"doc:\/\/org.swift.testing\/documentation\/Testing\/Test(_:_:arguments:_:)","type":"topic","abstract":[{"text":"Declare a test parameterized over two collections of values.","type":"text"}],"fragments":[{"kind":"keyword","text":"macro"},{"text":" ","kind":"text"},{"text":"Test","kind":"identifier"},{"kind":"text","text":"<"},{"text":"C1","kind":"genericParameter"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"C2"},{"kind":"text","text":">("},{"kind":"typeIdentifier","text":"String","preciseIdentifier":"s:SS"},{"kind":"text","text":"?, "},{"text":"any","kind":"keyword"},{"kind":"text","text":" "},{"kind":"typeIdentifier","preciseIdentifier":"s:7Testing9TestTraitP","text":"TestTrait"},{"kind":"text","text":"..., "},{"kind":"externalParam","text":"arguments"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:7Testing2C1L_xmfp","text":"C1","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"preciseIdentifier":"s:7Testing2C2L_q_mfp","text":"C2","kind":"typeIdentifier"},{"text":")","kind":"text"}]},"doc://org.swift.testing/documentation/Testing":{"title":"Testing","kind":"symbol","role":"collection","url":"\/documentation\/testing","type":"topic","abstract":[{"type":"text","text":"Create and run tests for your Swift packages and Xcode projects."}],"identifier":"doc:\/\/org.swift.testing\/documentation\/Testing"},"doc://org.swift.testing/documentation/Testing/Test(_:_:arguments:)-8kn7a":{"role":"symbol","title":"Test(_:_:arguments:)","url":"\/documentation\/testing\/test(_:_:arguments:)-8kn7a","kind":"symbol","identifier":"doc:\/\/org.swift.testing\/documentation\/Testing\/Test(_:_:arguments:)-8kn7a","type":"topic","abstract":[{"type":"text","text":"Declare a test parameterized over a collection of values."}],"fragments":[{"kind":"keyword","text":"macro"},{"kind":"text","text":" "},{"kind":"identifier","text":"Test"},{"kind":"text","text":"<"},{"text":"C","kind":"genericParameter"},{"kind":"text","text":">("},{"kind":"typeIdentifier","preciseIdentifier":"s:SS","text":"String"},{"text":"?, ","kind":"text"},{"text":"any","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:7Testing9TestTraitP","text":"TestTrait"},{"kind":"text","text":"..., "},{"text":"arguments","kind":"externalParam"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"C","preciseIdentifier":"s:7Testing1CL_xmfp"},{"kind":"text","text":")"}]},"doc://org.swift.testing/documentation/Testing/Parallelization":{"identifier":"doc:\/\/org.swift.testing\/documentation\/Testing\/Parallelization","role":"article","kind":"article","title":"Parallelizing test execution","abstract":[{"type":"text","text":"Control whether tests run serially or in parallel."}],"url":"\/documentation\/testing\/parallelization","type":"topic"},"doc://org.swift.testing/documentation/Testing/DefiningTests":{"identifier":"doc:\/\/org.swift.testing\/documentation\/Testing\/DefiningTests","type":"topic","role":"collectionGroup","abstract":[{"type":"text","text":"Define a test function to validate that code is working correctly."}],"title":"Defining test functions","url":"\/documentation\/testing\/definingtests","kind":"article"},"doc://org.swift.testing/documentation/Testing/Test/Case":{"identifier":"doc:\/\/org.swift.testing\/documentation\/Testing\/Test\/Case","navigatorTitle":[{"kind":"identifier","text":"Case"}],"role":"symbol","kind":"symbol","title":"Test.Case","abstract":[{"text":"A single test case from a parameterized ","type":"text"},{"identifier":"doc:\/\/org.swift.testing\/documentation\/Testing\/Test","isActive":true,"type":"reference"},{"text":".","type":"text"}],"url":"\/documentation\/testing\/test\/case","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"Case","kind":"identifier"}],"type":"topic"},"doc://org.swift.testing/documentation/Testing/Test(_:_:arguments:)-3rzok":{"role":"symbol","title":"Test(_:_:arguments:)","url":"\/documentation\/testing\/test(_:_:arguments:)-3rzok","kind":"symbol","type":"topic","identifier":"doc:\/\/org.swift.testing\/documentation\/Testing\/Test(_:_:arguments:)-3rzok","abstract":[{"type":"text","text":"Declare a test parameterized over two zipped collections of values."}],"fragments":[{"text":"macro","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Test","kind":"identifier"},{"text":"<","kind":"text"},{"kind":"genericParameter","text":"C1"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"C2"},{"kind":"text","text":">("},{"text":"String","kind":"typeIdentifier","preciseIdentifier":"s:SS"},{"kind":"text","text":"?, "},{"kind":"keyword","text":"any"},{"kind":"text","text":" "},{"kind":"typeIdentifier","preciseIdentifier":"s:7Testing9TestTraitP","text":"TestTrait"},{"kind":"text","text":"..., "},{"text":"arguments","kind":"externalParam"},{"kind":"text","text":": "},{"text":"Zip2Sequence","kind":"typeIdentifier","preciseIdentifier":"s:s12Zip2SequenceV"},{"text":"<","kind":"text"},{"kind":"typeIdentifier","text":"C1","preciseIdentifier":"s:7Testing2C1L_xmfp"},{"text":", ","kind":"text"},{"preciseIdentifier":"s:7Testing2C2L_q_mfp","kind":"typeIdentifier","text":"C2"},{"kind":"text","text":">)"}]},"doc://org.swift.testing/documentation/Testing/CustomTestArgumentEncodable":{"role":"symbol","title":"CustomTestArgumentEncodable","url":"\/documentation\/testing\/customtestargumentencodable","navigatorTitle":[{"kind":"identifier","text":"CustomTestArgumentEncodable"}],"kind":"symbol","identifier":"doc:\/\/org.swift.testing\/documentation\/Testing\/CustomTestArgumentEncodable","type":"topic","abstract":[{"text":"A protocol for customizing how arguments passed to parameterized tests are","type":"text"},{"type":"text","text":" "},{"type":"text","text":"encoded, which is used to match against when running specific arguments."}],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"CustomTestArgumentEncodable","kind":"identifier"}]},"https://en.wikipedia.org/wiki/Cartesian_product":{"title":"Cartesian product","titleInlineContent":[{"text":"Cartesian product","type":"text"}],"url":"https:\/\/en.wikipedia.org\/wiki\/Cartesian_product","identifier":"https:\/\/en.wikipedia.org\/wiki\/Cartesian_product","type":"link"},"doc://org.swift.testing/documentation/Testing/OrganizingTests":{"identifier":"doc:\/\/org.swift.testing\/documentation\/Testing\/OrganizingTests","title":"Organizing tests","type":"topic","role":"collectionGroup","url":"\/documentation\/testing\/organizingtests","abstract":[{"text":"Organize tests into test suites.","type":"text"}],"kind":"article"},"doc://org.swift.testing/documentation/Testing/Test":{"navigatorTitle":[{"kind":"identifier","text":"Test"}],"identifier":"doc:\/\/org.swift.testing\/documentation\/Testing\/Test","type":"topic","role":"symbol","abstract":[{"type":"text","text":"A type representing a test or suite."}],"title":"Test","url":"\/documentation\/testing\/test","kind":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"Test","kind":"identifier"}]}}}